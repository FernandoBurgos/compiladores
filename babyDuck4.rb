#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.8.1
# from Racc grammar file "babyDuck4.y".
#

require 'racc/parser.rb'


class SemanticError < StandardError; end

class BabyDuck < Racc::Parser

module_eval(<<'...end babyDuck4.y/module_eval...', 'babyDuck4.y', 387)
def parse(str)
  # Initialize semantic analysis variables
  @symbol_tables = {}
  @current_scope = nil
  @current_function = nil
  @current_vars = []
  @current_position = 0
  @var_type = nil
  @calling_function = nil
  @memory = {
    'global' => {
      'int' => {BP: 0, OF: 0},
      'float' => {BP: 1000, OF: 0},
    },
    'local' => {
      'int' => {BP: 2000, OF: 0},
      'float' => {BP: 3000, OF: 0},
    },
    'const' => {
      'int' => {BP: 4000, OF: 0},
      'float' => {BP: 5000, OF: 0},
    },
    'temp' => {BP: 6000, OF: 0}
  }
  @cuadruples = []
  @quad_counter = 0
  @jump_stack = []
  @const_dict = {}

  @semantic_Cube = {
    'int' => {
      'int' => 'int',
      'float' => 'float',
      'string' => 'error'
    },
    'float' => {
      'int' => 'float',
      'float' => 'float',
      'string' => 'error'
    },
    'string' => {
      'int' => 'error',
      'float' => 'error',
      'string' => 'string'
    },
    'bool' => {
      'int' => 'error',
      'float' => 'error',
      'string' => 'error'
    }
  }

  @q = []
  until str.empty?
    case str
    when /\A\s+/
      # Ignora los espacios en blanco
    when /\A(program|main|end|var|void|if|else|while|do|print|int|float)\b/
      # Palabras clave reservadas - devuelve el token como su propio nombre
      @q.push [$&, $&]
    when /\A[a-zA-Z][a-zA-Z0-9_]*/
      # Identificador
      @q.push [:ID, $&]
    when /\A[0-9]+\.[0-9]+/
      # Constante flotante
      @q.push [:CTE_FLOAT, $&.to_f]
    when /\A[0-9]+/
      # Constante entera
      @q.push [:CTE_INT, $&.to_i]
    when /\A\"[^\"]*\"/
      # Constante string (incluyendo las comillas)
      @q.push [:CTE_STRING, $&[1...-1]] # Eliminamos las comillas
    when /\A(==|!=|<=|>=|<|>)/o
      #operadores de comparación
      @q.push [$&, $&]
    when /\A.|\n/o
      # Cualquier otro carácter (operadores, paréntesis, etc.)
      s = $&
      @q.push [s, s]
    end
    str = $'
  end
  @q.push [false, '$end']
  do_parse
end

def next_token
  @q.shift
end

# Helper function to check if a variable exists in current scope or global scope
def variable_exists(var_name)
  # Check current scope first
  return true if @symbol_tables[@current_scope] && @symbol_tables[@current_scope][var_name]
  
  # Check global scope if we're not already in it
  return true if @current_scope != 'global' && @symbol_tables['global'][var_name]
  
  # Variable not found
  false
end

# Helper function to create a new memory offset
def new_memory_offset(type, scope = 'global')
  # Check if the type exists in the memory map
  if scope == 'temp'
    basePointer = @memory[scope][:BP]
    offset = @memory[scope][:OF]
    @memory[scope][:OF] += 1
    return basePointer + offset
  end
  if @memory[scope][type]
    basePointer = @memory[scope][type][:BP]
    offset = @memory[scope][type][:OF]
    @memory[scope][type][:OF] += 1
    return basePointer + offset
  else
    raise SemanticError, "Memory allocation: Type '#{type}' not found in memory map for scope '#{scope}'"
  end
end

# Helper function to create cuadruples
def create_cuadruple(op, arg1, arg2, result)
  if op != 'PRINT'
    result = new_memory_offset('', 'temp')
  end
  newCuadruple =  [ op, arg1, arg2, result ]
  @cuadruples.push(newCuadruple)
  puts "Cuadruple #{@cuadruples.length}: #{op} #{arg1} #{arg2} -> #{result}"
  return newCuadruple[3]
end

# Helper function to get variable data
def get_variable_data(var_name)
  # Check current scope first
  if @symbol_tables[@current_scope] && @symbol_tables[@current_scope][var_name]
    return @symbol_tables[@current_scope][var_name]
  end
  
  # Check global scope if we're not already in it
  if @current_scope != 'global' && @symbol_tables['global'][var_name]
    return @symbol_tables['global'][var_name]
  end
  
  # Variable not found
  nil
end

# Helper function to print the symbol table (for debugging)
def print_symbol_tables
  puts "\n==== SYMBOL TABLES ===="
  @symbol_tables.each do |scope, vars|
    puts "SCOPE: #{scope}"
    vars.each do |var_name, details|
      puts "  #{var_name}: #{details}"
    end
    puts ""
  end
  puts "======================="
end

# Helper function to print the cuadruples (for debugging)
def print_cuadruples
  puts "\n==== CUADRUPLES ===="
  @cuadruples.each_with_index do |cuadruple, index|
    puts "Cuadruple #{index + 1}: #{cuadruple[0]} #{cuadruple[1]} #{cuadruple[2]} -> #{cuadruple[3]}"
  end
  puts "======================="
end

# Helper to evaluate expression types
def evaluate_expression_types(type1, type2)
  if @semantic_Cube[type1] && @semantic_Cube[type1][type2]
    return @semantic_Cube[type1][type2]
  end
  return 'error'
end

def generate_goto
  # Generate a GOTO quadruple with a pending jump
  @jump_stack.push(@cuadruples.length)
  quad = create_cuadruple('GOTO', nil, nil, 'pending')
  return quad
end

def fill_goto(quad_index, jump_destination)
  # Fill in the pending GOTO with actual destination
  @cuadruples[quad_index][3] = jump_destination
end

...end babyDuck4.y/module_eval...
##### State transition tables begin ###

racc_action_table = [
    74,    75,    74,    75,    50,    50,    74,    75,    97,    98,
    99,    30,    31,    30,    31,    77,   108,    77,    74,    75,
     3,    77,   -73,    51,    51,    52,    52,    55,    55,     4,
    93,     5,    93,   110,   111,    74,    75,    74,    75,    74,
    75,    74,    75,    74,    75,    74,    75,    74,    75,     6,
    77,   -73,    77,     7,    77,    11,    77,    15,    77,    18,
    77,    19,    77,    74,    75,   104,   105,    20,    21,    22,
    23,    28,    34,    35,    37,    38,    39,    18,    77,    41,
    56,    28,    60,    62,    63,    65,    67,    68,    11,    18,
    34,    84,    34,    95,   112,   114,   116,    34,   118,   120,
   121,   122,   123,   127,   128,    34,   130,   131,   132,   134,
    15 ]

racc_action_check = [
    68,    68,   122,   122,    34,    44,    67,    67,    72,    72,
    72,    22,    22,    38,    38,    68,    79,   122,    73,    73,
     0,    67,    67,    34,    44,    34,    44,    34,    44,     1,
    68,     3,   122,    79,    79,    88,    88,    62,    62,    63,
    63,    65,    65,    77,    77,    96,    96,   101,   101,     4,
    88,    88,    62,     5,    63,     8,    65,     9,    77,    11,
    96,    12,   101,   103,   103,    76,    76,    14,    15,    17,
    18,    20,    24,    25,    27,    28,    29,    32,   103,    33,
    35,    37,    42,    50,    51,    53,    54,    55,    56,    59,
    64,    66,    69,    71,    81,    82,    83,    84,    85,    89,
    90,    91,    94,   106,   113,   115,   117,   118,   121,   123,
   135 ]

racc_action_pointer = [
    11,    29,   nil,    21,    49,    42,   nil,   nil,    41,    34,
   nil,    49,    49,   nil,    48,    58,   nil,    54,    54,   nil,
    61,   nil,    -6,   nil,    48,    53,   nil,    58,    60,    65,
   nil,   nil,    67,    66,    -6,    59,   nil,    71,    -4,   nil,
   nil,   nil,    57,   nil,    -5,   nil,   nil,   nil,   nil,   nil,
    57,    65,   nil,    66,    67,    68,    74,   nil,   nil,    79,
   nil,   nil,    33,    35,    66,    37,    59,     2,    -4,    68,
   nil,    82,     2,    14,   nil,   nil,    63,    39,   nil,     6,
   nil,    74,    65,    76,    73,    78,   nil,   nil,    31,    83,
    80,    85,   nil,   nil,    80,   nil,    41,   nil,   nil,   nil,
   nil,    43,   nil,    59,   nil,   nil,    83,   nil,   nil,   nil,
   nil,   nil,   nil,    93,   nil,    81,   nil,    95,    96,   nil,
   nil,    97,    -2,    98,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,    87,   nil ]

racc_action_default = [
   -83,   -83,    -1,   -83,   -83,   -83,   137,    -2,    -6,   -17,
    -5,   -10,   -83,   -16,   -83,   -83,    -7,   -83,   -11,    -3,
   -22,   -20,   -83,   -12,   -83,   -83,   -21,   -26,   -83,   -83,
   -14,   -15,   -83,   -83,   -29,   -83,   -23,   -83,   -83,    -8,
   -13,    -4,   -83,   -28,   -29,   -32,   -33,   -34,   -35,   -36,
   -71,   -83,   -67,   -83,   -83,   -83,    -6,   -25,   -24,   -10,
   -27,   -31,   -57,   -57,   -83,   -57,   -83,   -57,   -57,   -83,
    -9,   -83,   -38,   -45,   -46,   -47,   -50,   -57,   -54,   -83,
   -56,   -83,   -66,   -83,   -83,   -83,   -72,   -74,   -57,   -76,
   -83,   -79,   -81,   -82,   -83,   -37,   -57,   -40,   -41,   -42,
   -43,   -57,   -48,   -57,   -51,   -52,   -83,   -55,   -58,   -59,
   -60,   -61,   -62,   -83,   -64,   -83,   -68,   -83,   -83,   -75,
   -77,   -83,   -57,   -83,   -39,   -44,   -49,   -53,   -63,   -65,
   -69,   -70,   -78,   -80,   -18,   -17,   -19 ]

racc_goto_table = [
    12,    33,    71,    81,    90,    83,     9,    16,    92,    85,
    26,    42,    29,   124,     1,     2,     8,   106,   125,    24,
    40,    61,    59,    32,    25,   135,    36,    57,    58,    96,
   119,   126,   100,   101,   102,   103,   107,   109,    64,   113,
   115,    82,    66,   nil,   nil,   nil,    94,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,    69,    70,   nil,   nil,   133,   nil,
   nil,   117,    92,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   129,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   136 ]

racc_goto_check = [
     4,     5,    29,    29,    52,    29,     3,     9,    29,    48,
    18,    21,    11,    30,     1,     2,     6,    29,    30,     7,
    10,    21,    12,    13,    16,    17,    20,    18,    11,    31,
    48,    32,    33,    34,    36,    37,    40,    41,    42,    43,
    44,     5,    46,   nil,   nil,   nil,     5,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,     3,     9,   nil,   nil,    52,   nil,
   nil,     5,    29,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,     5,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,     4 ]

racc_goto_pointer = [
   nil,    14,    15,    -2,    -9,   -23,     9,     0,   nil,    -4,
   -12,   -10,   -17,     0,   nil,   nil,     4,  -109,   -10,   nil,
    -1,   -23,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   -60,
   -83,   -43,   -72,   -41,   -40,   nil,   -42,   -41,   nil,   nil,
   -43,   -42,   -13,   -43,   -42,   nil,   -11,   nil,   -58,   nil,
   nil,   nil,   -64,   nil ]

racc_goto_default = [
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,    10,   nil,
    17,   nil,   nil,   nil,    13,    14,   nil,   nil,   nil,    27,
   nil,   nil,    43,    44,    45,    46,    47,    48,    49,    89,
    72,   nil,    73,   nil,    80,    76,   nil,   nil,    78,    79,
   nil,   nil,   nil,   nil,   nil,    53,   nil,    54,   nil,    86,
    87,    88,   nil,    91 ]

racc_reduce_table = [
  0, 0, :racc_error,
  1, 36, :_reduce_none,
  0, 41, :_reduce_2,
  0, 42, :_reduce_3,
  10, 37, :_reduce_4,
  1, 38, :_reduce_none,
  0, 38, :_reduce_none,
  2, 43, :_reduce_none,
  0, 47, :_reduce_8,
  6, 44, :_reduce_none,
  0, 44, :_reduce_none,
  1, 45, :_reduce_11,
  0, 48, :_reduce_12,
  4, 45, :_reduce_13,
  1, 46, :_reduce_14,
  1, 46, :_reduce_15,
  1, 39, :_reduce_none,
  0, 39, :_reduce_none,
  0, 52, :_reduce_18,
  11, 49, :_reduce_none,
  2, 50, :_reduce_20,
  1, 51, :_reduce_none,
  0, 51, :_reduce_none,
  2, 53, :_reduce_none,
  3, 54, :_reduce_24,
  2, 55, :_reduce_none,
  0, 55, :_reduce_none,
  3, 40, :_reduce_none,
  1, 56, :_reduce_none,
  0, 56, :_reduce_none,
  1, 57, :_reduce_none,
  2, 57, :_reduce_none,
  1, 58, :_reduce_none,
  1, 58, :_reduce_none,
  1, 58, :_reduce_none,
  1, 58, :_reduce_none,
  1, 58, :_reduce_none,
  4, 59, :_reduce_37,
  1, 64, :_reduce_38,
  3, 64, :_reduce_39,
  1, 66, :_reduce_40,
  1, 66, :_reduce_41,
  1, 66, :_reduce_42,
  2, 65, :_reduce_43,
  2, 68, :_reduce_44,
  0, 68, :_reduce_45,
  1, 69, :_reduce_46,
  1, 69, :_reduce_47,
  2, 67, :_reduce_48,
  2, 71, :_reduce_49,
  0, 71, :_reduce_50,
  1, 72, :_reduce_51,
  1, 72, :_reduce_52,
  3, 70, :_reduce_53,
  1, 70, :_reduce_54,
  2, 73, :_reduce_55,
  1, 74, :_reduce_56,
  0, 74, :_reduce_57,
  1, 75, :_reduce_58,
  1, 75, :_reduce_59,
  1, 76, :_reduce_60,
  1, 76, :_reduce_61,
  3, 77, :_reduce_62,
  5, 60, :_reduce_63,
  1, 79, :_reduce_64,
  2, 78, :_reduce_none,
  0, 78, :_reduce_none,
  1, 80, :_reduce_67,
  3, 81, :_reduce_68,
  5, 61, :_reduce_69,
  5, 62, :_reduce_70,
  1, 82, :_reduce_71,
  1, 83, :_reduce_none,
  0, 83, :_reduce_none,
  1, 84, :_reduce_none,
  2, 84, :_reduce_none,
  1, 85, :_reduce_76,
  2, 86, :_reduce_77,
  5, 63, :_reduce_78,
  1, 87, :_reduce_79,
  3, 87, :_reduce_80,
  1, 88, :_reduce_81,
  1, 88, :_reduce_82 ]

racc_reduce_n = 83

racc_shift_n = 137

racc_token_table = {
  false => 0,
  :error => 1,
  "*" => 2,
  "/" => 3,
  "+" => 4,
  "-" => 5,
  ">" => 6,
  "<" => 7,
  "!=" => 8,
  "program" => 9,
  :ID => 10,
  ";" => 11,
  "main" => 12,
  "end" => 13,
  "var" => 14,
  ":" => 15,
  "," => 16,
  "int" => 17,
  "float" => 18,
  "(" => 19,
  ")" => 20,
  "[" => 21,
  "]" => 22,
  "void" => 23,
  "{" => 24,
  "}" => 25,
  "=" => 26,
  :CTE_INT => 27,
  :CTE_FLOAT => 28,
  "if" => 29,
  "else" => 30,
  "while" => 31,
  "do" => 32,
  "print" => 33,
  :CTE_STRING => 34 }

racc_nt_base = 35

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]
Ractor.make_shareable(Racc_arg) if defined?(Ractor)

Racc_token_to_s_table = [
  "$end",
  "error",
  "\"*\"",
  "\"/\"",
  "\"+\"",
  "\"-\"",
  "\">\"",
  "\"<\"",
  "\"!=\"",
  "\"program\"",
  "ID",
  "\";\"",
  "\"main\"",
  "\"end\"",
  "\"var\"",
  "\":\"",
  "\",\"",
  "\"int\"",
  "\"float\"",
  "\"(\"",
  "\")\"",
  "\"[\"",
  "\"]\"",
  "\"void\"",
  "\"{\"",
  "\"}\"",
  "\"=\"",
  "CTE_INT",
  "CTE_FLOAT",
  "\"if\"",
  "\"else\"",
  "\"while\"",
  "\"do\"",
  "\"print\"",
  "CTE_STRING",
  "$start",
  "target",
  "program",
  "vars",
  "funcs",
  "body",
  "@1",
  "@2",
  "varsdec",
  "varlist",
  "varsids",
  "type",
  "@3",
  "@4",
  "funcsdec",
  "func_header",
  "funcvars",
  "@5",
  "funcvarsdec",
  "param_declaration",
  "funcvarsdeclist",
  "statement",
  "statedec",
  "statevalues",
  "assign",
  "condition",
  "cycle",
  "fcall",
  "printstat",
  "expression",
  "exp",
  "operator",
  "term",
  "termlist",
  "termop",
  "factor",
  "factorlist",
  "factorop",
  "factorids",
  "expop",
  "expids",
  "const",
  "ifExpression",
  "optionalelse",
  "elseKeyword",
  "whileHeader",
  "whileExrpession",
  "function_id",
  "funccallexp",
  "funcexplist",
  "single_param",
  "single_param_comma",
  "printexplist",
  "printvalue" ]
Ractor.make_shareable(Racc_token_to_s_table) if defined?(Ractor)

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

# reduce 1 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 14)
  def _reduce_2(val, _values, result)
          # Initialize the symbol tables
      @current_scope = 'global'
      @symbol_tables = { 'global' => {} }
      @current_function = nil

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 20)
  def _reduce_3(val, _values, result)
          @current_scope = 'main'
      @symbol_tables['main'] = {}

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 24)
  def _reduce_4(val, _values, result)
          puts "Codigo compilado correctamente"
      result = val[1]

    result
  end
.,.,

# reduce 5 omitted

# reduce 6 omitted

# reduce 7 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 32)
  def _reduce_8(val, _values, result)
          # Add all variables of this type to the current scope
      puts "Received type: #{@var_type}"
      @current_vars.each do |var_name|
        if @symbol_tables[@current_scope][var_name]
          raise SemanticError, "Variable decalration: Variable '#{var_name}' already declared in scope '#{@current_scope}'"
        else
          scope = @current_scope == 'global' ? 'global' : 'local'
          @symbol_tables[@current_scope][var_name] = {type: @var_type, offset: new_memory_offset(@var_type, scope)}
          puts "Added variable '#{var_name}' of type '#{@var_type}' to scope '#{@current_scope}'"
        end
      end

    result
  end
.,.,

# reduce 9 omitted

# reduce 10 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 46)
  def _reduce_11(val, _values, result)
          @current_vars = [val[0]]

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 49)
  def _reduce_12(val, _values, result)
          @current_vars = [val[0]]

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 52)
  def _reduce_13(val, _values, result)
          @current_vars.unshift(val[0])

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 55)
  def _reduce_14(val, _values, result)
        @var_type = 'int'
    result = 'int'

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 59)
  def _reduce_15(val, _values, result)
        @var_type = 'float'
    result = 'float'

    result
  end
.,.,

# reduce 16 omitted

# reduce 17 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 66)
  def _reduce_18(val, _values, result)
        # Return to global scope after function definition
    @current_scope = 'global'
    @current_function = nil

    result
  end
.,.,

# reduce 19 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 73)
  def _reduce_20(val, _values, result)
        # Store function name
    @current_function = val[1]
    @current_scope = val[1]
    @symbol_tables[@current_scope] = {}
    puts "Created new function scope: #{@current_scope}"
    
    # Return the function name for potential use in parent rule
    result = val[1]

    result
  end
.,.,

# reduce 21 omitted

# reduce 22 omitted

# reduce 23 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 87)
  def _reduce_24(val, _values, result)
        var_name = val[0]
    
    if @symbol_tables[@current_scope][var_name]
      raise SemanticError, "Parameter declaration: Parameter '#{var_name}' already declared in function '#{@current_scope}'"
    else
      @symbol_tables[@current_scope][var_name] = {type: val[2], offset: new_memory_offset(val[2], 'local'), is_param: true}
      puts "Added parameter '#{var_name}' of type '#{val[2]}' to function '#{@current_scope}'"
    end
    
    # Return the parameter name for potential use in parent rule
    result = var_name

    result
  end
.,.,

# reduce 25 omitted

# reduce 26 omitted

# reduce 27 omitted

# reduce 28 omitted

# reduce 29 omitted

# reduce 30 omitted

# reduce 31 omitted

# reduce 32 omitted

# reduce 33 omitted

# reduce 34 omitted

# reduce 35 omitted

# reduce 36 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 112)
  def _reduce_37(val, _values, result)
          puts "Assigned value to variable: #{val[0]}"
      # Check if variable exists in current scope or global scope
      var_name = val[0]
      var_offset = get_variable_data(var_name)[:offset]
      if !variable_exists(var_name)
        raise SemanticError, "Assignment: Variable '#{var_name}' not declared before use"
      end

      resultingType = val[2][:type]
      if evaluate_expression_types(get_variable_data(var_name)[:type], resultingType) == 'error'
        raise SemanticError, "Assignment: Type mismatch in assignment to variable '#{var_name}'"
      end
      create_cuadruple('=', val[2][:offset], var_offset, 'result')

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 129)
  def _reduce_38(val, _values, result)
        result = val[0]  # Pass up the exp value

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 132)
  def _reduce_39(val, _values, result)
        left = val[0]
    op = val[1]
    right = val[2]

    evaluation = create_cuadruple(op, left[:offset], right[:offset], 'result')
    puts "DEBUG: Expression with operator: #{op}"

    result = { name: 'Evalresult', type: 'bool', offset: evaluation, op: op }

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 142)
  def _reduce_40(val, _values, result)
     result = '>'
    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 143)
  def _reduce_41(val, _values, result)
     result = '<'
    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 144)
  def _reduce_42(val, _values, result)
     result = '!='
    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 147)
  def _reduce_43(val, _values, result)
        if val[1].nil? || val[1].empty?  # No operations in termlist
      result = val[0]  # Just pass up the term value
    else
      # Handle operations from termlist
      term = val[0]
      ops = val[1]
      puts "DEBUG: Exp with termlist operation"
      
      resultingType = evaluate_expression_types(term[:type], ops[:type])
        # Check if the types are compatible
        if resultingType == 'error'
          raise SemanticError, "Assignment: Type mismatch in expression"
        end

      # Create the cuadruple for the operation
      evaluation = create_cuadruple(ops[:operator], term[:offset], ops[:offset], 'result')

      result = { name: 'Evalresult', type: resultingType, offset: evaluation }
    end

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 169)
  def _reduce_44(val, _values, result)
        result = { operator: val[0], name: val[1][:name], type: val[1][:type], offset: val[1][:offset] }

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 172)
  def _reduce_45(val, _values, result)
        result = nil  # No operations

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 175)
  def _reduce_46(val, _values, result)
     result = '+'
    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 176)
  def _reduce_47(val, _values, result)
     result = '-'
    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 179)
  def _reduce_48(val, _values, result)
        if val[1].nil? || val[1].empty?  # No operations in factorlist
      result = val[0]  # Just pass up the factor value
    else
      # Handle operations from factorlist
      factor = val[0]
      ops = val[1]
      puts "DEBUG: Term with factorlist operation"

      resultingType = evaluate_expression_types(factor[:type], ops[:type])
        # Check if the types are compatible
        if resultingType == 'error'
          raise SemanticError, "Assignment: Type mismatch in expression"
        end

      # Create the cuadruple for the operation
      evaluation = create_cuadruple(ops[:operator], factor[:offset], ops[:offset], 'result')

      result = { name: 'Evalresult', type: resultingType, offset: evaluation }
    end

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 201)
  def _reduce_49(val, _values, result)
        result = { operator: val[0], name: val[1][:name], type: val[1][:type], offset: val[1][:offset] }

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 204)
  def _reduce_50(val, _values, result)
        result = nil  # No operations

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 207)
  def _reduce_51(val, _values, result)
     result = '*'
    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 208)
  def _reduce_52(val, _values, result)
     result = '/'
    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 211)
  def _reduce_53(val, _values, result)
        result = val[1]  # Return the expression inside parentheses

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 214)
  def _reduce_54(val, _values, result)
        result = val[0]  # Pass up the factorids value

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 218)
  def _reduce_55(val, _values, result)
        if val[0].nil? || val[0].empty?  # No operator
      result = val[1]  # Just pass up the expids value
    else
      # Apply unary operator
      op = val[0]
      value = val[1]
      puts "DEBUG: Factorids with expop operation"
      result = { operator: op, offset: value[:offset] }
    end

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 230)
  def _reduce_56(val, _values, result)
        result = val[0]  # Pass up the termop value

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 233)
  def _reduce_57(val, _values, result)
        result = nil  # No operator

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 237)
  def _reduce_58(val, _values, result)
        # Check if variable exists when used in expression
    var_name = val[0]
    if !variable_exists(var_name)
      raise SemanticError, "Expression: Variable '#{var_name}' not declared before use"
    end
    var_data = get_variable_data(var_name)
    var_offset = var_data[:offset]
    var_type = var_data[:type]
    result = { name: var_name, type: var_type, offset: var_offset }

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 248)
  def _reduce_59(val, _values, result)
        result = val[0]  # Pass up the const value

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 252)
  def _reduce_60(val, _values, result)
        if @const_dict[val[0]] != nil
      memoryAddress = @const_dict[val[0]]
    else
      memoryAddress = new_memory_offset('int', 'const')
      @const_dict[val[0]] = memoryAddress
    end
    result = {name: 'int const', type: 'int', offset: memoryAddress }

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 261)
  def _reduce_61(val, _values, result)
        if @const_dict[val[0]] != nil
      memoryAddress = @const_dict[val[0]]
    else
      memoryAddress = new_memory_offset('float', 'const')
      @const_dict[val[0]] = memoryAddress
    end
    result = { name: 'float const', type: 'float', offset: memoryAddress }

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 272)
  def _reduce_62(val, _values, result)
        if val[1][:op] == nil
      raise SemanticError, "Expression: The expression inside the if must evaluate a boolean"
    end
    # Create a false jump for the if condition
    @jump_stack.push(@cuadruples.length)
    false_jump = create_cuadruple('GOTOF', val[1][:offset], nil, "pending")

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 280)
  def _reduce_63(val, _values, result)
        false_jump_index = @jump_stack.pop
    
    # Fill the false jump with the exit point
    fill_goto(false_jump_index, @cuadruples.length+1)

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 286)
  def _reduce_64(val, _values, result)
        false_jump_index = @jump_stack.pop
    
    # Fill the false jump with the exit point
    fill_goto(false_jump_index, @cuadruples.length+2)

    # Create a GOTO to skip the else body
    @jump_stack.push(@cuadruples.length)
    create_cuadruple('GOTO', nil, nil, "pending")

    result
  end
.,.,

# reduce 65 omitted

# reduce 66 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 299)
  def _reduce_67(val, _values, result)
        @jump_stack.push(@cuadruples.length + 1)

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 303)
  def _reduce_68(val, _values, result)
        # Create a false jump for the while condition
    @jump_stack.push(@cuadruples.length)
    false_jump = create_cuadruple('GOTOF', val[1][:offset], nil, "pending")

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 311)
  def _reduce_69(val, _values, result)
        false_jump_index = @jump_stack.pop
    start_quad = @jump_stack.pop
    
    # Generate return GOTO to beginning of while
    generate_goto
    # Fill the return GOTO with the start of the while
    fill_goto(@cuadruples.length-1, start_quad)
    
    # Fill the false jump with the exit point
    fill_goto(false_jump_index, @cuadruples.length+1)
    

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 326)
  def _reduce_70(val, _values, result)
        # Reset function calling state
    @calling_function = nil
    result = val[0]  # Return the function ID from function_id rule

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 332)
  def _reduce_71(val, _values, result)
        func_name = val[0]
    
    # Check if function exists
    if !@symbol_tables[func_name]
      raise SemanticError, "Function call: Function '#{func_name}' not declared before use"
    end
    
    # Set up function call state
    @current_param_count = 0
    @calling_function = func_name
    
    # Return the function name for use in parent rule
    result = func_name

    result
  end
.,.,

# reduce 72 omitted

# reduce 73 omitted

# reduce 74 omitted

# reduce 75 omitted

module_eval(<<'.,.,', 'babyDuck4.y', 351)
  def _reduce_76(val, _values, result)
        @current_param_count += 1
    result = val[0]  # Return the expression value

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 356)
  def _reduce_77(val, _values, result)
        @current_param_count += 1
    result = val[0]  # Return the expression value

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 361)
  def _reduce_78(val, _values, result)
     result = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 363)
  def _reduce_79(val, _values, result)
        result = val[0]

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 366)
  def _reduce_80(val, _values, result)
        result = val[2]

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 369)
  def _reduce_81(val, _values, result)
        create_cuadruple('PRINT', nil, nil, val[0][:offset])
    result = val[0]

    result
  end
.,.,

module_eval(<<'.,.,', 'babyDuck4.y', 373)
  def _reduce_82(val, _values, result)
        create_cuadruple('PRINT', nil, nil, val[0])
    result = {name: 'string const', type: 'string'}

    result
  end
.,.,

def _reduce_none(val, _values, result)
  val[0]
end

end   # class BabyDuck


if $0 == __FILE__
  parser = BabyDuck.new
  # Código para probar tu parser

  if ARGV[0]
    input = File.read(ARGV[0])
    begin
      result = parser.parse(input)
      # Print symbol tables for debugging
      parser.print_symbol_tables
      parser.print_cuadruples
      puts "Análisis exitoso: #{result}"
    rescue SemanticError => e
      puts "Semantic Error: #{e.message}"
    end
  end
end
